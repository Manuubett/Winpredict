<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Soccer Prediction Tool</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Add Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }
        
        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --danger: #e74c3c;
            --warning: #f39c12;
            /* Updated backgrounds to gold, blue, red gradient */
            --dark-bg: linear-gradient(135deg, #FFD700, #1a2a6c, #e74c3c);
            --dark-card: rgba(30, 40, 70, 0.7);
            --dark-text: #fff;
            --light-bg: linear-gradient(135deg, #FFF9C4, #BBDEFB, #FFCDD2);
            --light-card: rgba(255, 255, 255, 0.85);
            --light-text: #2c3e50;
            --header-gradient: linear-gradient(135deg, #1a2a6c, #2c3e50);
            --header-light: linear-gradient(135deg, #3498db, #2ecc71);
        }
        
        body.dark-mode {
            background: var(--dark-bg);
            color: var(--dark-text);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
        }
        
        body.light-mode {
            background: var(--light-bg);
            color: var(--light-text);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
        }
        
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            position: relative;
        }
        
        body.light-mode header {
            border-bottom: 2px solid rgba(0,0,0,0.1);
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #00b4db, #0083b0);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        body.light-mode header h1 {
            background: linear-gradient(to right, #1a2a6c, #3498db);
        }
        
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #fff;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        
        body.light-mode .theme-toggle {
            background: rgba(0,0,0,0.05);
            color: #2c3e50;
        }
        
        .theme-toggle:hover {
            transform: rotate(15deg);
        }
        
        .card {
            background: var(--dark-card);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        body.light-mode .card {
            background: var(--light-card);
            border: 1px solid rgba(0,0,0,0.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .card h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            color: #4fc3f7;
            font-size: 1.8rem;
        }
        
        body.light-mode .card h2 {
            color: #1a2a6c;
        }
        
        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-box {
            flex: 1;
            min-width: 200px;
        }
        
        .input-box label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        .input-box input, .input-box select {
            width: 100%;
            padding: 14px;
            border-radius: 10px;
            border: 2px solid #3498db;
            background: rgba(20, 30, 60, 0.7);
            color: white;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }
        
        body.light-mode .input-box input, 
        body.light-mode .input-box select {
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            border: 2px solid #3498db;
        }
        
        .input-box input:focus, .input-box select:focus {
            border-color: #1abc9c;
            outline: none;
            box-shadow: 0 0 0 3px rgba(26, 188, 156, 0.3);
        }
        
        .btn {
            background: linear-gradient(45deg, #00c9ff, #92fe9d);
            color: #1a2a6c;
            border: none;
            padding: 14px 30px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .result-card {
            background: rgba(25, 35, 75, 0.8);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }
        
        body.light-mode .result-card {
            background: rgba(255, 255, 255, 0.7);
        }
        
        .result-card:hover {
            transform: translateY(-5px);
        }
        
        .result-card h3 {
            color: #64ffda;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        body.light-mode .result-card h3 {
            color: #1a2a6c;
        }
        
        .match-list ul {
            list-style: none;
        }
        
        .match-list li {
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
        }
        
        body.light-mode .match-list li {
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .match-list li:last-child {
            border-bottom: none;
            font-weight: bold;
            color: #64ffda;
            padding-top: 15px;
            margin-top: 10px;
            border-top: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        body.light-mode .match-list li:last-child {
            color: #1a2a6c;
            border-top: 1px solid rgba(26, 42, 108, 0.3);
        }
        
        .match-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .match-list ul {
            list-style: none;
        }
        
        .match-list li {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: rgba(40, 50, 90, 0.6);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        body.light-mode .match-list li {
            background: rgba(255, 255, 255, 0.7);
        }
        
        .match-list li b {
            color: #64ffda;
            flex: 1;
            min-width: 250px;
        }
        
        body.light-mode .match-list li b {
            color: #1a2a6c;
        }
        
        .match-list li small {
            opacity: 0.8;
            font-size: 0.9rem;
        }
        
        .search-box {
            margin-bottom: 20px;
            position: relative;
        }
        
        .search-box input {
            width: 100%;
            padding: 14px 14px 14px 45px;
            border-radius: 10px;
            border: 2px solid #3498db;
            background: rgba(20, 30, 60, 0.7);
            color: white;
            font-size: 1.1rem;
        }
        
        body.light-mode .search-box input {
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
        }
        
        .search-box i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.7;
        }
        
        .feedback-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .feedback-btn {
            flex: 1;
            padding: 12px;
            border-radius: 10px;
            border: none;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .feedback-btn.right {
            background: linear-gradient(45deg, #00b09b, #96c93d);
            color: white;
        }
        
        .feedback-btn.wrong {
            background: linear-gradient(45deg, #ff416c, #ff4b2b);
            color: white;
        }
        
        .feedback-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .feedback-btn:active {
            transform: translateY(1px);
        }
        
        .toggle-btn {
            background: rgba(20, 30, 60, 0.7);
            color: white;
            border: 2px solid #3498db;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        body.light-mode .toggle-btn {
            background: rgba(255, 255, 255, 0.7);
            color: #2c3e50;
        }
        
        .toggle-btn:hover {
            background: rgba(30, 40, 80, 0.9);
        }
        
        body.light-mode .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.9);
        }
        
        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-weight: 500;
        }
        
        .status.success {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
        }
        
        .status.error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
        }
        
        .status.processing {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
        }
        
        .migration-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(45deg, #ff9966, #ff5e62);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        .migration-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        /* Score frequency styles */
        .score-bar {
            margin: 10px 0;
        }
        
        .score-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .score-bar-bg {
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        body.light-mode .score-bar-bg {
            background: rgba(0,0,0,0.05);
        }
        
        .score-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00c9ff, #92fe9d);
            border-radius: 10px;
        }
        
        .score-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }
        
        .score-cell {
            background: rgba(40, 50, 90, 0.6);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: transform 0.2s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .score-cell:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        .score-cell .score {
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 5px;
        }
        
        .score-cell .probability {
            font-size: 0.85rem;
            opacity: 0.9;
        }
        
        .score-cell .confidence-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #3498db;
        }
        
        .goal-range-chart {
            display: flex;
            height: 120px;
            align-items: flex-end;
            justify-content: space-around;
            margin-top: 20px;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }
        
        .range-bar {
            width: 60px;
            background: linear-gradient(to top, #00c9ff, #92fe9d);
            border-radius: 5px 5px 0 0;
            position: relative;
            text-align: center;
            padding-top: 5px;
            font-weight: bold;
        }
        
        .range-bar .value {
            position: absolute;
            top: -25px;
            left: 0;
            right: 0;
            font-size: 1.1rem;
        }
        
        .range-bar .label {
            position: absolute;
            bottom: -25px;
            left: 0;
            right: 0;
        }
        
        .confidence-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
        }
        
        .confidence-level {
            font-size: 2rem;
            font-weight: bold;
            margin-right: 15px;
            background: linear-gradient(45deg, #00c9ff, #92fe9d);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .confidence-description {
            max-width: 300px;
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00c9ff, #92fe9d);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .processing-message {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.1rem;
        }
        
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            header h1 {
                font-size: 2rem;
            }
            
            .score-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            }
        }
    </style>
</head>
<body class="dark-mode">
    <div class="container">
        <header>
            <h1><i class="fas fa-futbol"></i> Soccer Score Predictor</h1>
            <p>Advanced predictive analytics for correct scores and goal ranges</p>
            <div style="font-size: 0.9rem; color: yellow;">
                Subscription ends in <span id="timer">--:--:--</span>
            </div>
            <button class="theme-toggle" onclick="toggleTheme()">
                <i class="fas fa-sun"></i>
            </button>
        </header>
        
        <div class="card">
            <h2><i class="fas fa-sliders-h"></i> Match Parameters</h2>
            <div class="input-group">
                <div class="input-box">
                    <label for="homeOdds"><i class="fas fa-home"></i> Home Odds</label>
                    <input id="homeOdds" type="number" step="0.01" placeholder="e.g. 2.10" value="2.10">
                </div>
                <div class="input-box">
                    <label for="drawOdds"><i class="fas fa-equals"></i> Draw Odds</label>
                    <input id="drawOdds" type="number" step="0.01" placeholder="e.g. 3.25" value="3.25">
                </div>
                <div class="input-box">
                    <label for="awayOdds"><i class="fas fa-car-side"></i> Away Odds</label>
                    <input id="awayOdds" type="number" step="0.01" placeholder="e.g. 3.80" value="3.80">
                </div>
                <div class="input-box">
                    <label for="modelType"><i class="fas fa-brain"></i> Prediction Model</label>
                    <select id="modelType">
                        <option value="bayesian">Bayesian Analysis</option>
                        <option value="poisson">Poisson Distribution</option>
                        <option value="ensemble">Ensemble Modeling</option>
                    </select>
                </div>
            </div>
            <button class="btn" onclick="runPrediction()">
                <i class="fas fa-calculator"></i> Generate Predictions
            </button>
        </div>
        
        <div id="output" class="status"></div>
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="results-grid">
            <div class="result-card" id="suggestionsCard" style="display:none;">
                <h3><i class="fas fa-lightbulb"></i> Suggestions</h3>
                <div id="suggestionContent" style="font-size: 1.1rem; line-height: 1.6;"></div>
            </div>
            
            <div class="result-card" id="scoreCard" style="display:none;">
                <h3><i class="fas fa-bullseye"></i> Score Probabilities</h3>
                <div class="score-grid" id="scoreGrid"></div>
            </div>
            
            <div class="result-card" id="goalRangeCard" style="display:none;">
                <h3><i class="fas fa-bullseye"></i> Goal Range Analysis</h3>
                <div id="goalRangeAnalysis">
                    <div class="goal-range-chart" id="goalRangeChart"></div>
                </div>
            </div>
            
            <div class="result-card" id="confidenceCard" style="display:none;">
                <h3><i class="fas fa-star"></i> Prediction Confidence</h3>
                <div class="confidence-indicator">
                    <div class="confidence-level" id="confidenceScore">-</div>
                    <div class="confidence-description" id="confidenceDescription">
                        Confidence score represents the reliability of predictions based on historical data patterns
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card" id="scoreFrequency" style="display:none;">
            <h2><i class="fas fa-chart-pie"></i> Historical Score Distribution</h2>
            <div id="scoreFrequencyContent">
                <!-- Score bars will be generated here -->
            </div>
        </div>
        
        <div class="card" id="feedbackSection" style="display:none;">
            <h2><i class="fas fa-comment-dots"></i> Prediction Feedback</h2>
            <p>Was this prediction accurate?</p>
            <div class="feedback-buttons">
                <button class="feedback-btn right" onclick="logFeedback('right')">
                    <i class="fas fa-check-circle"></i> ✅ Accurate
                </button>
                <button class="feedback-btn wrong" onclick="logFeedback('wrong')">
                    <i class="fas fa-times-circle"></i> ❌ Inaccurate
                </button>
            </div>
        </div>
        
        <div class="card">
            <h2><i class="fas fa-clipboard-list"></i> Historical Match Records</h2>
            <div class="search-box">
                <i class="fas fa-search"></i>
                <input type="text" id="searchTeam" placeholder="Search by team name..." oninput="filterMatchList()">
            </div>
            <div class="match-list">
                <ul id="matchList"></ul>
            </div>
        </div>
    </div>
    
    <button class="migration-btn" onclick="migrateTeamData()">
        <i class="fas fa-tools"></i> Fix Team Names
    </button>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDthFB2btT_r6slyX_xa5jeDOX8KDxsmdo",
            authDomain: "store-1d9e8.firebaseapp.com",
            projectId: "store-1d9e8",
            storageBucket: "store-1d9e8.appspot.com",
            messagingSenderId: "869478006120",
            appId: "1:869478006120:web:2045cbb98db8a3755e6add"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // Global variables
        let lastPrediction = null;
        let currentExactMatches = [];
        
        // ─── Odds-normalising helpers ───────────────────────────────
        const getOdds = (doc) => ({
          home: Number(doc.odds1  ?? doc.odd1  ?? doc.homeOdds ?? doc.home_odd  ?? NaN),
          draw: Number(doc.oddsX  ?? doc.draw  ?? doc.oddX     ?? doc.drawOdds  ?? NaN),
          away: Number(doc.odds2  ?? doc.odd2  ?? doc.awayOdds ?? doc.away_odd  ?? NaN),
        });

        const isClose = (a, b, eps = 0.02) =>
          !isNaN(a) && !isNaN(b) && Math.abs(a - b) < eps;
        
        // Toggle theme
        function toggleTheme() {
            const body = document.body;
            const themeToggle = document.querySelector('.theme-toggle i');
            
            if (body.classList.contains('dark-mode')) {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                themeToggle.classList.remove('fa-sun');
                themeToggle.classList.add('fa-moon');
            } else {
                body.classList.remove('light-mode');
                body.classList.add('dark-mode');
                themeToggle.classList.remove('fa-moon');
                themeToggle.classList.add('fa-sun');
            }
        }
        
        // Bayesian adjustment function
        function bayesianAdjust(rate, n, prior = 50, weight = 100) {
            return ((rate * n) + (prior * weight)) / (n + weight);
        }
        
        // Poisson distribution function
        function poisson(k, lambda) {
            return Math.exp(-lambda) * Math.pow(lambda, k) / factorial(k);
        }
        
        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }
        
        // Load cached matches from localStorage or Firestore
        async function loadCachedMatches() {
            const cached = localStorage.getItem('recentMatches');
            const lastFetch = localStorage.getItem('lastFetch');
            const now = Date.now();
            
            if (cached && lastFetch && now - lastFetch < 5 * 60 * 1000) {
                return JSON.parse(cached);
            }
            
            try {
                const snapshot = await db.collection("matches").orderBy("timestamp", "desc").limit(500).get();
                const recent = snapshot.docs.map(doc => doc.data());
                
                localStorage.setItem('recentMatches', JSON.stringify(recent));
                localStorage.setItem('lastFetch', now);
                return recent;
            } catch (error) {
                console.error("Error loading match data:", error);
                document.getElementById('output').textContent = "❌ Failed to load match data. Please check your connection.";
                document.getElementById('output').className = "status error";
                return [];
            }
        }
        
        // Enhanced team name extraction
        function extractTeams(m = {}) {
            // Comprehensive field name checks
            const teamFields = [
                'homeTeam', 'awayTeam', 'home', 'away', 
                'teamA', 'teamB', 'team1', 'team2',
                'home_name', 'away_name', 'teams'
            ];
            
            // Check for direct team fields
            for (const field of teamFields) {
                if (m[field] && Array.isArray(m[field]) && m[field].length === 2) {
                    return m[field];
                }
            }
            
            // Try to parse from match string
            if (m.match && typeof m.match === 'string') {
                // Enhanced cleaning for various formats
                const cleaned = m.match
                    .replace(/\s+vs?\.?/gi, ' vs ')
                    .replace(/\s*[\(\{\[].*?[\)\}\]]\s*/g, '')  // Remove anything in brackets
                    .replace(/[^a-zA-Z0-9\s\-]/g, '')  // Remove special chars except hyphens
                    .replace(/\s{2,}/g, ' ')  // Collapse multiple spaces
                    .trim();
                
                // Split using multiple delimiters
                const teams = cleaned.split(/\s+vs\s+|\sv\s|\s-\s|\s@\s/i);
                
                if (teams.length === 2) {
                    return teams.map(t => t.trim());
                }
            }
            
            // Last resort - log and use fallback
            console.warn('Team name extraction failed for document:', m);
            return ['Team A', 'Team B'];
        }
        
        // Show progress bar and status
        function showProgress(message, percent) {
            const outputEl = document.getElementById('output');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            
            outputEl.innerHTML = `<div class="processing-message"><div class="spinner"></div> ${message}</div>`;
            outputEl.className = "status processing";
            
            if (percent !== undefined) {
                progressContainer.style.display = 'block';
                progressBar.style.width = `${percent}%`;
            } else {
                progressContainer.style.display = 'none';
            }
        }
        
        // Show results cards
        function showResultsCards() {
            document.getElementById('suggestionsCard').style.display = 'block';
            document.getElementById('scoreCard').style.display = 'block';
            document.getElementById('goalRangeCard').style.display = 'block';
            document.getElementById('confidenceCard').style.display = 'block';
            document.getElementById('scoreFrequency').style.display = 'block';
            document.getElementById('feedbackSection').style.display = 'block';
        }
        
        // Run prediction algorithm
        async function runPrediction() {
            // Cache DOM elements
            const outputEl = document.getElementById('output');
            const homeOddsInput = document.getElementById('homeOdds');
            const drawOddsInput = document.getElementById('drawOdds');
            const awayOddsInput = document.getElementById('awayOdds');
            const modelTypeSel = document.getElementById('modelType');
            
            // UI setup
            showProgress('Loading match data...');
            
            // Hide results cards
            document.getElementById('suggestionsCard').style.display = 'none';
            document.getElementById('scoreCard').style.display = 'none';
            document.getElementById('goalRangeCard').style.display = 'none';
            document.getElementById('confidenceCard').style.display = 'none';
            document.getElementById('scoreFrequency').style.display = 'none';
            document.getElementById('feedbackSection').style.display = 'none';
            
            // Get input values
            const home = parseFloat(homeOddsInput.value);
            const draw = parseFloat(drawOddsInput.value);
            const away = parseFloat(awayOddsInput.value);
            const modelType = modelTypeSel.value;
            
            // Validate inputs
            if (![home, draw, away].every(v => typeof v === 'number' && !isNaN(v) && v >= 1.01 && v <= 1000)) {
                outputEl.textContent = '❌ Please enter valid odds between 1.01 and 1000.';
                outputEl.className = "status error";
                return;
            }
            
            // Load matches
            showProgress('Loading historical data...', 10);
            const recentMatches = await loadCachedMatches();
            
            // Find tolerant matches
            showProgress('Finding matching odds...', 30);
            const exactMatches = recentMatches.filter(doc => {
                const { home: h, draw: d, away: a } = getOdds(doc);
                return isClose(home, h) && isClose(draw, d) && isClose(away, a);
            });
            
            // Handle no matches found
            if (exactMatches.length === 0) {
                outputEl.textContent = '❌ No exact match found in the database.';
                outputEl.className = "status error";
                return;
            }
            
            // Display matches and process data
            displayExactMatchList(exactMatches);
            
            const data = exactMatches;
            let totalW = 0;
            const scores = {};
            const goalRanges = {
                "0-1": 0,
                "2-3": 0,
                "4+": 0
            };
            
            // Process each match in chunks
            showProgress('Analyzing match results...', 50);
            const chunkSize = 50;
            let processed = 0;
            const totalMatches = data.length;
            
            while (processed < totalMatches) {
                const chunk = data.slice(processed, Math.min(processed + chunkSize, totalMatches));
                processed += chunkSize;
                
                for (const m of chunk) {
                    const [a, b] = (m.result || '').split('-').map(Number);
                    if (!isNaN(a) && !isNaN(b)) {
                        totalW += 1;
                        const goals = a + b;
                        const score = `${a}-${b}`;
                        
                        // Score tracking
                        scores[score] = (scores[score] || 0) + 1;
                        
                        // Goal ranges
                        if (goals <= 1) goalRanges["0-1"]++;
                        else if (goals <= 3) goalRanges["2-3"]++;
                        else goalRanges["4+"]++;
                    }
                }
                
                // Update progress
                const percent = 50 + Math.floor((processed / totalMatches) * 30);
                showProgress(`Analyzing match results (${processed}/${totalMatches})...`, percent);
                
                // Yield to main thread to update UI
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            
            // Calculate probabilities using selected model
            showProgress('Calculating predictions...', 90);
            let scoreProbabilities = {};
            let goalRangeProbabilities = {};
            let confidenceScore = 0;
            
            if (modelType === "bayesian") {
                // Bayesian adjustments
                const bayes = (count, total) => bayesianAdjust(count, total, 0.5, 25);
                
                // Calculate score probabilities
                for (const [score, count] of Object.entries(scores)) {
                    scoreProbabilities[score] = bayes(count, totalW);
                }
                
                // Calculate goal range probabilities
                for (const [range, count] of Object.entries(goalRanges)) {
                    goalRangeProbabilities[range] = bayes(count, totalW);
                }
                
                // Confidence based on data quality
                confidenceScore = Math.min(100, Math.floor(totalW / 5) * 10);
            } 
            else if (modelType === "poisson") {
                // Calculate implied probabilities from odds
                const implied = [home, draw, away].map(o => 1 / o);
                const margin = implied.reduce((a, b) => a + b, 0); // bookmaker's overround
                const stripped = implied.map(p => p / margin);     // remove margin
                const totalProb = stripped.reduce((a, b) => a + b, 0);
                const [normHome, normDraw, normAway] = stripped.map(p => p / totalProb);
                
                // Calculate expected goals
                let hSum = 0, aSum = 0, cnt = 0;
                data.forEach(m => {
                    const [h, a] = (m.result || '').split('-').map(Number);
                    if (!isNaN(h) && !isNaN(a)) { hSum += h; aSum += a; cnt++; }
                });
                const fallbackH = normHome * 1.4;
                const fallbackA = normAway * 1.2;
                const homeExpected = cnt ? hSum / cnt : fallbackH;
                const awayExpected = cnt ? aSum / cnt : fallbackA;
                
                // Generate score probabilities using Poisson distribution
                for (let homeGoals = 0; homeGoals <= 5; homeGoals++) {
                    for (let awayGoals = 0; awayGoals <= 5; awayGoals++) {
                        const prob = poisson(homeGoals, homeExpected) * poisson(awayGoals, awayExpected);
                        const score = `${homeGoals}-${awayGoals}`;
                        scoreProbabilities[score] = prob * 100;
                    }
                }
                
                // Calculate goal range probabilities
                goalRangeProbabilities = {
                    "0-1": 0,
                    "2-3": 0,
                    "4+": 0
                };
                
                for (const [score, prob] of Object.entries(scoreProbabilities)) {
                    const [a, b] = score.split('-').map(Number);
                    const goals = a + b;
                    
                    if (goals <= 1) goalRangeProbabilities["0-1"] += prob;
                    else if (goals <= 3) goalRangeProbabilities["2-3"] += prob;
                    else goalRangeProbabilities["4+"] += prob;
                }
                
                // Confidence based on odds quality
                const oddsQuality = Math.max(normHome, normDraw, normAway);
                confidenceScore = Math.min(100, Math.floor(oddsQuality * 100));
            } 
            else { // Ensemble modeling
                // Combine historical data with Poisson model
                const bayes = (count, total) => bayesianAdjust(count, total, 0.5, 10);
                
                // Calculate score probabilities from historical data
                let historicalScores = {};
                for (const [score, count] of Object.entries(scores)) {
                    historicalScores[score] = bayes(count, totalW);
                }
                
                // Calculate Poisson probabilities
                const homeProb = 1 / home;
                const drawProb = 1 / draw;
                const awayProb = 1 / away;
                const totalProb = homeProb + drawProb + awayProb;
                const normHome = homeProb / totalProb;
                const normAway = awayProb / totalProb;
                const homeExpected = normHome * 1.5;
                const awayExpected = normAway * 1.2;
                
                let poissonScores = {};
                for (let homeGoals = 0; homeGoals <= 5; homeGoals++) {
                    for (let awayGoals = 0; awayGoals <= 5; awayGoals++) {
                        const prob = poisson(homeGoals, homeExpected) * poisson(awayGoals, awayExpected);
                        const score = `${homeGoals}-${awayGoals}`;
                        poissonScores[score] = prob * 100;
                    }
                }
                
                // Combine models with weights
                const historicalWeight = Math.min(0.85, totalW / 25);
                const poissonWeight = 1 - historicalWeight;
                
                // Combine scores
                const allScores = new Set([...Object.keys(historicalScores), ...Object.keys(poissonScores)]);
                for (const score of allScores) {
                    const histProb = historicalScores[score] || 0;
                    const poisProb = poissonScores[score] || 0;
                    scoreProbabilities[score] = (histProb * historicalWeight) + (poisProb * poissonWeight);
                }
                
                // Calculate goal range probabilities
                goalRangeProbabilities = {
                    "0-1": 0,
                    "2-3": 0,
                    "4+": 0
                };
                
                for (const [score, prob] of Object.entries(scoreProbabilities)) {
                    const [a, b] = score.split('-').map(Number);
                    const goals = a + b;
                    
                    if (goals <= 1) goalRangeProbabilities["0-1"] += prob;
                    else if (goals <= 3) goalRangeProbabilities["2-3"] += prob;
                    else goalRangeProbabilities["4+"] += prob;
                }
                
                // Confidence based on both models
                confidenceScore = Math.min(100, Math.floor((totalW * 2) + (poissonWeight * 50)));
            }
            
            // Normalize probabilities to sum to 100
            let totalScoreProb = Object.values(scoreProbabilities).reduce((sum, prob) => sum + prob, 0);
            for (const score in scoreProbabilities) {
                scoreProbabilities[score] = (scoreProbabilities[score] / totalScoreProb) * 100;
            }
            
            // Sort scores by probability
            const sortedScores = Object.entries(scoreProbabilities)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 12);
            
            // Update UI with results
            displayScoreProbabilities(sortedScores);
            displayGoalRangeProbabilities(goalRangeProbabilities);
            document.getElementById('confidenceScore').textContent = confidenceScore.toFixed(1) + '%';
            
            // Show all result cards
            showResultsCards();
            
            // Suggest most likely correct score and goal range
            const topScore = sortedScores[0]?.[0] || "N/A";
            const topGoalRange = Object.entries(goalRangeProbabilities).sort((a, b) => b[1] - a[1])[0]?.[0] || "N/A";
            
            document.getElementById('suggestionContent').innerHTML = `
                <p><strong>Suggested Correct Score:</strong> ${topScore}</p>
                <p><strong>Likely Goal Range:</strong> ${topGoalRange}</p>
            `;
            
            outputEl.textContent = `✅ ${exactMatches.length} exact match(es) found. Using ${modelType} model for predictions.`;
            outputEl.className = "status success";
            
            // Display score frequencies
            displayScoreFrequencies(scores);
            
            // Store last prediction for feedback
            lastPrediction = { 
                odds_used: { home, draw, away }, 
                model: modelType,
                scoreProbabilities,
                goalRangeProbabilities,
                confidenceScore
            };
        }
        
        // Display score probabilities
        function displayScoreProbabilities(scores) {
            const scoreGrid = document.getElementById('scoreGrid');
            let html = '';
            
            scores.forEach(([score, probability]) => {
                // Scale confidence bar height (0-100% of cell height)
                const barHeight = Math.min(100, probability * 1.5);
                
                html += `
                    <div class="score-cell">
                        <div class="score">${score}</div>
                        <div class="probability">${probability.toFixed(1)}%</div>
                        <div class="confidence-bar" style="height: ${barHeight}%"></div>
                    </div>
                `;
            });
            
            scoreGrid.innerHTML = html;
        }
        
        // Display goal range probabilities
        function displayGoalRangeProbabilities(ranges) {
            const goalRangeChart = document.getElementById('goalRangeChart');
            let html = '';
            const maxValue = Math.max(...Object.values(ranges));
            
            for (const [range, probability] of Object.entries(ranges)) {
                // Scale bar height (0-100% of chart height)
                const barHeight = Math.min(100, (probability / maxValue) * 100);
                
                html += `
                    <div class="range-bar" style="height: ${barHeight}%">
                        <div class="value">${probability.toFixed(1)}%</div>
                        <div class="label">${range}</div>
                    </div>
                `;
            }
            
            goalRangeChart.innerHTML = html;
        }
        
        // Display score frequencies
        function displayScoreFrequencies(scores) {
            const scoreFreq = Object.entries(scores)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const total = scoreFreq.reduce((sum, [_, count]) => sum + count, 0);
            
            let html = '';
            scoreFreq.forEach(([score, count]) => {
                const percentage = ((count / total) * 100).toFixed(1);
                html += `
                    <div class="score-bar">
                        <div class="score-info">
                            <span>${score}</span>
                            <span>${count} times (${percentage}%)</span>
                        </div>
                        <div class="score-bar-bg">
                            <div class="score-bar-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('scoreFrequencyContent').innerHTML = html;
        }
        
        // Display exact match list
        function displayExactMatchList(matches) {
            currentExactMatches = matches;
            const list = matches.map(m => {
                const [home, away] = extractTeams(m);
                const time = m.timestamp?.seconds ?
                    new Date(m.timestamp.seconds * 1000).toLocaleDateString() : '';
                return `
                    <li>
                        <b>${home} vs ${away}</b> — ${m.result || 'N/A'} 
                        <small>${time}</small>
                    </li>
                `;
            }).join('');
            document.getElementById('matchList').innerHTML = list;
        }
        
        // Filter match list
        function filterMatchList() {
            const q = document.getElementById('searchTeam').value.toLowerCase().trim();
            const filtered = currentExactMatches.filter(m => {
                const [home, away] = extractTeams(m).map(t => t.toLowerCase());
                return home.includes(q) || away.includes(q);
            });
            displayExactMatchList(filtered);
        }
        
        // Log feedback
        async function logFeedback(type) {
            if (!lastPrediction) return;
            
            // Disable buttons during submission
            document.querySelectorAll("#feedbackSection button").forEach(btn => {
                btn.disabled = true;
            });
            
            const payload = {
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                odds: lastPrediction.odds_used,
                model: lastPrediction.model,
                prediction: {
                    scores: lastPrediction.scoreProbabilities,
                    goalRanges: lastPrediction.goalRangeProbabilities,
                    confidence: lastPrediction.confidenceScore
                },
                feedback: type
            };
            
            try {
                await db.collection("feedback_logs").add(payload);
                document.getElementById('output').textContent = `✅ Feedback recorded: ${type}`;
                document.getElementById('output').className = "status success";
            } catch (error) {
                document.getElementById('output').textContent = "❌ Failed to record feedback";
                document.getElementById('output').className = "status error";
                console.error("Error logging feedback:", error);
            }
            
            // Hide feedback section after submission
            setTimeout(() => {
                document.getElementById('feedbackSection').style.display = 'none';
            }, 2000);
        }
        
        // Migrate team data
        async function migrateTeamData() {
            const btn = document.querySelector('.migration-btn');
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Fixing Team Names...';
            btn.disabled = true;
            
            try {
                const snapshot = await db.collection("matches").get();
                const batch = db.batch();
                let count = 0;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const [home, away] = extractTeams(data);
                    
                    // Only update if we found better names
                    if (!home.includes('Team A') || !away.includes('Team B')) {
                        batch.update(doc.ref, {
                            homeTeam: home,
                            awayTeam: away
                        });
                        count++;
                    }
                });
                
                await batch.commit();
                document.getElementById('output').textContent = `✅ Team names updated for ${count} documents`;
                document.getElementById('output').className = "status success";
                
                // Clear cache to force reload
                localStorage.removeItem('recentMatches');
                localStorage.removeItem('lastFetch');
                
                // Reload data
                await runPrediction();
            } catch (error) {
                document.getElementById('output').textContent = "❌ Migration failed. Check console for details.";
                document.getElementById('output').className = "status error";
                console.error("Migration failed:", error);
            }
            
            btn.innerHTML = '<i class="fas fa-check"></i> Team Names Fixed!';
            setTimeout(() => {
                btn.innerHTML = '<i class="fas fa-tools"></i> Fix Team Names';
                btn.disabled = false;
            }, 3000);
        }
        
        // Initialize on load
        window.onload = function() {
            // Set sample data for demo
            document.getElementById('homeOdds').value = "2.10";
            document.getElementById('drawOdds').value = "3.25";
            document.getElementById('awayOdds').value = "3.80";
        };
    </script>
</body>
</html>